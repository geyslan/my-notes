# KRSI = LSM + BPF

## Checking environment

Check if the running kernel supports `KRSI` (**LSM** and **BPF hooks**).

```bash
❯ zgrep 'bpf\|BPF_LSM' /proc/config.gz 
CONFIG_BPF_LSM=y
CONFIG_LSM="lockdown,yama,bpf"
```

## eBPF (kernelspace)

eBPF programs that use **BPF Type Format (BTF)** do not need to include kernel headers for accessing information from the attached eBPF program’s context. *They can simply declare the structures in the eBPF program and only specify the fields that need to be accessed.*

```c
struct mm_struct {
        unsigned long start_brk, brk, start_stack;
} __attribute__((preserve_access_index));
```

Anyway, this can be further simplified (if one has access to the BTF information at build time) by generating the `vmlinux.h` with:

```bash
❯ bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
```

The `vmlinux.h` can then simply be included in the BPF programs without requiring the definition of the types.

## eBPF (userspace)

eBPF programs can be loaded with the *bpf(2)* syscall's `BPF_PROG_LOAD` operation:

```c
struct bpf_object *obj;

obj = bpf_object__open("./my_prog.o");
bpf_object__load(obj);

```
This can be simplified by using a skeleton header generated by `bpftool`:

```bash
❯ bpftool gen skeleton my_prog.o > my_prog.skel.h
```

and the program can be loaded by including `my_prog.skel.h` and using the generated helper, `my_prog__open_and_load`.

---

### References

[The Linux Kernel - BPF Documentation - LSM BPF Programs](https://www.kernel.org/doc/html/latest/bpf/bpf_lsm.html)
