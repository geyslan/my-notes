# KRSI = LSM + BPF

## Checking environment

Check if the running kernel supports `KRSI` (**LSM** and **BPF hooks**).

```bash
❯ zgrep 'bpf\|BPF_LSM\|DEBUG_INFO_BTF' /proc/config.gz
CONFIG_BPF_LSM=y
CONFIG_LSM="lockdown,yama,bpf"
CONFIG_DEBUG_INFO_BTF=y
CONFIG_DEBUG_INFO_BTF_MODULES=y
```

## Kernel files

These kernel headers contain LSM hooks information:

* `include/linux/lsm_hook_defs.h`  (hook declarations)
* `include/linux/lsm_hooks.h`      (hook informations)

The testing (sample) sources can be found in the `tools/testing/selftests/bpf` path.

## eBPF (kernelspace)

eBPF programs that use **BPF Type Format (BTF)** do not need to include kernel headers for accessing information from the attached eBPF program’s context. *They can simply declare the structures in the eBPF program and only specify the fields that need to be accessed.*

```c
struct mm_struct {
        unsigned long start_brk, brk, start_stack;
} __attribute__((preserve_access_index));
```

Anyway, this can be further simplified (if one has access to the BTF information at build time) by generating the `vmlinux.h` with:

```bash
❯ bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
```

The `vmlinux.h` can then simply be included in the BPF programs without requiring the definition of the types.

### Sample

```c
#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <errno.h>

char _license[] SEC("license") = "GPL";

/* @socket_bind:
 *      Check permission before socket protocol layer bind operation is
 *      performed and the socket @sock is bound to the address specified in the
 *      @address parameter.
 *      @sock contains the socket structure.
 *      @address contains the address to bind to.
 *      @addrlen contains the length of address.
 *      Return 0 if permission is granted.
 */
SEC("lsm/socket_bind")
int BPF_PROG(bind_krsi,
             struct socket *sock, struct sockaddr *address, int addrlen)
{
        struct sockaddr_in *sock_ip4;
        int is_dynamic = 0;

        /* ret is the return value from the previous BPF program
         * or 0 if it's the first hook.
         */
        if (ret != 0)
                return ret;

        if (sock->type != SOCK_STREAM || address->sa_family != AF_INET)
                return 0;
        
        sock_ip4 = (struct sockaddr_in *) address;
        is_dynamic = sock_ip4->sin_port == 0;

        /* Return an -EPERM or write information to the perf events buffer
         * for auditing
         */
        if (is_dynamic)
                return -EPERM;
}
```

## eBPF (userspace)

eBPF programs can be loaded with the *bpf(2)* syscall's `BPF_PROG_LOAD` operation:

```c
struct bpf_object *obj;

obj = bpf_object__open("./my_prog.o");
bpf_object__load(obj);

```

This can be simplified by using a skeleton header generated by `bpftool`:

```bash
❯ bpftool gen skeleton my_prog.o > my_prog.skel.h
```

and the program can be loaded by including `my_prog.skel.h` and using the generated helper, `my_prog__open_and_load`.

---

### References

* [Several BPF documentation files in the kernel](https://github.com/torvalds/linux/tree/master/Documentation/bpf)
* [The Linux Kernel - BPF Documentation - LSM BPF Programs](https://www.kernel.org/doc/html/latest/bpf/bpf_lsm.html)
* [LSM samples](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/)
  * kernelspace
    * [tools/testing/selftests/bpf/progs/bprm_opts.c](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/bprm_opts.c)
    * [tools/testing/selftests/bpf/progs/ima.c](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/ima.c)
    * [tools/testing/selftests/bpf/progs/local_storage.c](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/local_storage.c)
    * [tools/testing/selftests/bpf/progs/lsm.c](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/lsm.c)
  * userspace
    * [tools/testing/selftests/bpf/prog_tests/test_bprm_opts.c](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/prog_tests/test_bprm_opts.c)
    * [tools/testing/selftests/bpf/prog_tests/test_ima.c](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/prog_tests/test_ima.c)
    * [tools/testing/selftests/bpf/prog_tests/test_local_storage.c](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/prog_tests/test_local_storage.c)    
    * [tools/testing/selftests/bpf/prog_tests/lsm_prog.c](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/prog_tests/test_lsm.c)
* [Mitigating Attacks on a Supercomputer with KRSI - Billy Wilson](https://www.sans.org/reading-room/whitepapers/intrusion/mitigating-attacks-supercomputer-krsi-40010)
